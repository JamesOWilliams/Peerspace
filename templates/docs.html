{% load static %}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keywords" content="">

    <title>Documentation | Peerspace</title>
    <link rel="shortcut icon" href="{% static 'img/favicon.ico' %}">

    <!-- Styles -->
    <link href="{% static 'assets/css/theDocs.all.min.css' %}" rel="stylesheet">
    <link href="{% static 'assets/css/custom.css' %}" rel="stylesheet">
    <link href="{% static 'css/docs.css' %}" rel="stylesheet">

    <!-- Fonts -->
    <link href='http://fonts.googleapis.com/css?family=Raleway:100,300,400,500%7CLato:300,400' rel='stylesheet' type='text/css'>

    <!-- Favicons -->
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="icon" href="assets/img/favicon.png">

    <!-- MathJax -->
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

  </head>

  <body data-spy="scroll" data-target=".sidebar" data-offset="200">


    <!-- Sidebar -->
    <aside class="sidebar sidebar-boxed sidebar-dark">

      <a class="sidebar-brand" href="/"><img src="{% static 'img/logo.png' %}" class="logo" alt="logo"></a>

      <ul class="nav sidenav">
        <li><a href="#html-structure">The Entry Point</a></li>
        <li><a href="#variations">Settings</a></li>

        <li>
          <a href="#title1">Users App</a>
          <ul>
            <li><a href="#subtitle1">User Manager</a></li>
            <li>
              <a href="#subtitle2">User Model</a>
              <ul>
                <li><a href="#subtitle2-1">SignUpView</a></li>
                <li><a href="#subtitle2-2">UpdateProfile</a></li>
                <li><a href="#subtitle2-3">LogoutView</a></li>
                <li>
                  <a href="#subtitle2-4">Profile View</a>
                  <ul>
                    <li><a href="#subtitle2-4-1">Your Profile</a></li>
                    <li><a href="#subtitle2-4-2">Another's Profile</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#subtitle3">Templates</a></li>
          </ul>
        </li>
        <li><a href="#title2">Posts App</a>
          <ul>
            <li>
              <a href="#subtitle4">Post Model</a>
              <ul>
                <li><a href="#subtitle4-1">Post List View</a></li>
                <li><a href="#subtitle4-2">Post Edit View</a></li>
                <li><a href="#subtitle4-3">Post Prove View</a></li>
                <li>
                  <a href="#subtitle4-4">Post View</a>
                  <ul>
                    <li><a href="#subtitle4-4-1">Your Post</a></li>
                    <li><a href="#subtitle4-4-2">Another's Post</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="#subtitle5">Post Feed</a>
              <ul>
                <li><a href="#subtitle5-1">Preference Tags</a>
                  <ul>
                    <li><a href="#subtitle5-1-1">User Tag Model</a></li>
                    <li><a href="#subtitle5-1-2">Post Tags</a></li>
                  </ul>
                </li>
                <li><a href="#subtitle6">Relevance Algorithm</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#title3">API</a></li>
        <li><a href="#title4">Conclusion</a></li>
      </ul>

    </aside>
    <!-- END Sidebar -->


    <header class="site-header navbar-transparent">

      <!-- Top navbar & branding -->
      <nav class="navbar navbar-default">
        <div class="container-fluid">

          <!-- Toggle buttons and brand -->
          <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar" aria-expanded="true" aria-controls="navbar">
              <span class="icon icon-option-vertical"></span>
            </button>

            <button type="button" class="navbar-toggle for-sidebar" data-toggle="offcanvas">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

          </div>
          <!-- END Toggle buttons and brand -->

          <!-- Top navbar -->
          <div id="navbar" class="navbar-collapse collapse" aria-expanded="true" role="banner">
            <ul class="nav navbar-nav navbar-right">
              <li class="active"><a href="/">Back to main site</a></li>
              <li><a href="#">Github</a></li>
              <li><a href="#" target="_blank">Support</a></li>
              <li class="hero"><a href="{% url 'login' %}">Login</a></li>
            </ul>
          </div>
          <!-- END Top navbar -->

        </div>
      </nav>
      <!-- END Top navbar & branding -->

      <!-- Banner -->
      <div class="banner auto-size" style="background-color: #6A0F49">
        <div class="container-fluid text-white">
          <h1><strong>Peerspace</strong> documentation</h1>
          <h5>A line-by-line explaination of how Peerspace works.</h5>
        </div>
      </div>
      <!-- END Banner -->

    </header>

    <main class="container-fluid">

      <!-- Main content -->
      <article class="main-content" role="main">



<!-- <pre class="line-by-line"><code class="markdown">

  .
  ├── _.git
  ├── _media
  |   └── some test media files (actuall files stored on S3)
  ├── _notifications
  |   ├── __pychache__
  |   ├── migrations
  |   |   └── All migrations for notifications app
  |   └── __init__.py
  |   └── admin.py
  |   └── apps.py
  |   └── models.py
  |   └── tests.py
  |   └── urls.py
  |   └── views.py
  ├── _Peerspace
  |   ├── __pychache__
  |   └── __init__.py
  |   └── settings.py
  |   └── urls.py
  |   └── views.py
  |   └── wsgi.py
  ├── _posts
  |   ├── __pychache__
  |   ├── migrations
  |   ├── templates
  |   |   ├── posts
  |   |   └── edit_post.html
  |   |   └── post_confirm_delete.html
  |   |   └── post_detail_user.html
  |   |   └── post_detail.html
  |   |   └── post_list.html
  |   |   └── prove_post_delete_confirm.html
  |   |   └── prove_post.html
  |   └── __init__.py
  |   └── admin.py
  |   └── apps.py
  |   └── feed.py
  |   └── forms.py
  |   └── models.py
  |   └── serializers.py
  |   └── tests.py
  |   └── urls.py
  |   └── views.py
  ├── _search
  |   ├── 2007-10-29-why-every-programmer-should-play-nethack.md
  |   └── 2009-04-26-barcamp-boston-4-roundup.md
  ├── _sent_emails
  |   ├── _base.scss
  |   └── _layout.scss
  ├── static
  ├── .jekyll-metadata
  └── index.html # can also be an 'index.md' with valid YAML Frontmatter

</code></pre> -->

        <p class="lead">Here is an in-depth description of how Peerspace works. This page contains the detail missed out in the report, I understand there was a limit on the length of the report but there was not mention of how long the
        suporting documentation could be...</p>

        <section>
          <h2 id="html-structure">The entry-point</h2>
          <p>The manage.py file is the file that allows me to run commandline instructions. From the commandline I can run the local server, create users and much more.</p>

<pre class="line-numbers"><code class="language-python">
  #!/usr/bin/env python
  import os
  import sys

  if __name__ == "__main__":
      os.environ.setdefault("DJANGO_SETTINGS_MODULE", "Peerspace.settings")
      try:
          from django.core.management import execute_from_command_line
      except ImportError as exc:
          raise ImportError(
              "Couldn't import Django. Are you sure it's installed and "
              "available on your PYTHONPATH environment variable? Did you "
              "forget to activate a virtual environment?"
          ) from exc
      execute_from_command_line(sys.argv)


</code></pre>

        </section>


        <section>
          <h2 id="variations">Settings</h2>
          <p>Django comes with some default settings, I haven't changed many of these. Below are the key settings that I added or changed.</p>
          <p>Peerspace uses <a href="https://aws.amazon.com/s3/" target="_blank">Amazon Web Services S3</a> to serve static files (JavaScript, CSS, images on the homepage and logo, etc...) and media files (user profile pictures and cover pictures, etc...).
            In order for Django to retrieve these files from S3 I had to set up a bucket on in the S3 console and define some settings in my <code>settings.py</code> file.</p>


          <pre class="line-numbers"><code class="language-python">

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.0/howto/static-files/

STATIC_ROOT = ''
STATIC_URL = '/static/'
STATICFILES_DIRS = ( os.path.join('static'), )

MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
MEDIA_URL = '/media/'

AUTH_USER_MODEL = 'users.User'

EMAIL_BACKEND = 'django.core.mail.backends.filebased.EmailBackend'
EMAIL_FILE_PATH = os.path.join(BASE_DIR, 'sent_emails')

# REST Framework
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.SessionAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticatedOrReadOnly',
    ),
    'DEFAULT_FILTER_BACKENDS': (
        'django_filters.rest_framework.DjangoFilterBackend',
    ),
}

LOGIN_REDIRECT_URL = '/posts'



STATICFILES_LOCATION = '/static/'
STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'

MEDIAFILES_LOCATION = '/media/'
DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'

# Update database configuration with $DATABASE_URL.
import dj_database_url
db_from_env = dj_database_url.config(conn_max_age=500)
DATABASES['default'].update(db_from_env)

"""
This will tell boto that when it uploads files to S3, it should set properties on them so that when S3 serves them, it'll include some HTTP headers in the response.
"""
AWS_S3_OBJECT_PARAMETERS = {
    'Expires': 'Thu, 31 Dec 2099 20:00:00 GMT',
    'CacheControl': 'max-age=94608000',
}

AWS_STORAGE_BUCKET_NAME = 'peerspace'
AWS_S3_REGION_NAME = 'eu-west-2'  # e.g. us-east-2
AWS_ACCESS_KEY_ID = 'AKIAIWX5HLLVM7KJ5UEA'
AWS_SECRET_ACCESS_KEY = '****************************************'

# Tell django-storages the domain to use to refer to static files.
AWS_S3_CUSTOM_DOMAIN = '%s.s3.amazonaws.com' % AWS_STORAGE_BUCKET_NAME

# Tell the staticfiles app to use S3Boto3 storage when writing the collected static files (when
# you run `collectstatic`).
STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'

DEFAULT_IMAGE_PATH = 'default_profile_pic.svg'

          </code></pre>


        </section>


        <section>
          <h2 id="title1">Users App</h2>
          <p>The user application manages everything todo with the user. It allows users to signup, signin and logout. It allows users to follow other users and upload photos (soon it will allow users to receive notifications and message other users).</p>
          <p>It also manages the permissions within the site. For example a user cannot edit another user's information or profile, it also manages user authenticatoion; only logged in users can interact with the site</p>

          <h3 id="subtitle1">User Manager</h3>
          <p>Django comes with a basic user model that you can use straight out of the box, although this is useful it did not fit the user model I needed for Peerspace. As the user model
          is specific to every application Django makes it very easy to abstract the base user model, allowing you me customise it to my heart's content.</p>
          <p>The <code>UserManager</code> class extends the <code>BaseUserManager</code> class. This allows me to customise the user creation process by defining what fields are requeired
          when signing up. It also lets me perform operations on the information that the user inputs, for example I have normalised the format of all email addresses across the site are congruent.</p>

          <pre class="line-numbers"><code class="language-python">
                                                                    # These imports allow me to extend/abstract the base user model.
from django.contrib.auth.models import (
    AbstractBaseUser,
    BaseUserManager,
    PermissionsMixin
)
                                                                    # Standard imports
from django.db import models
from django.utils import timezone
from django.conf import settings

from django_fields import DefaultStaticImageField

                                                                    # The user manager class controls how users and superusers are created
                                                                    # It extends the base user manager that comes with Django
class UserManager(BaseUserManager):
                                                                    # This method is run when a new user is created
    def create_user(self, email, name, password):
                                                                    # Check to see if the user has provided an email.
        if not email:
                                                                    # If not then raise an error
            raise ValueError('Please provide an E-Mail address')
                                                                    # Initialise the user model
        user = self.model(
                                                                    # The normalize_email() function will make sure that all the emails
                                                                    # across the project are formatted identically
            email=self.normalize_email(email),
            name=name,
        )
                                                                    # The set_password() function manages the passwork security such as the
                                                                    # password hashing
        user.set_password(password)
                                                                    # Save the user to the database
                                                                    # Set the default profile and cover pictures
        user.save
                                                                    # Return the user
        return user

                                                                    # This method is called when a superuser is created, this will be done in
                                                                    # the command line
    def create_superuser(self, email, name, password):
                                                                    # Take the info from the create_user() method
        user = self.create_user(
            email,
            name,
            password
        )
                                                                    # Set the is_staff value to True
        user.is_staff = True
                                                                    # Set the is_superuser value to True
        user.is_superuser = True
                                                                    # Save the superuser to the database
        user.save()
                                                                    # Return the superuser
        return user
          </code></pre>

          <h3 id="subtitle2">User Model</h3>
            <p>The user models defines the table used to store user data. The classes attributes define the columns in the table and the methods can perform opeations using the data.</p>
            <p>In a similar fashion to the user manager the <code>User</code> class extends the <code>AbstractBaseUser</code> class, it also extends the <code>PermissionsMixin</code> class (I shall talk more on that later), this
              allows me to add columns and customise the base user model whilst keeping all of the functionality that comes with Django's base user.</p>

            <pre class="line-numbers"><code class="language-python">

                                                                    # This class is my custom user model
class User(AbstractBaseUser, PermissionsMixin):
                                                                    # The users email is used as the unique identifier of their account
    email = models.EmailField(unique=True)
                                                                    # This field holds the name of the user
                                                                    # (they can decide whether to give both first and last name or ethier.)
    name = models.CharField(max_length=72, default='')
                                                                    # This field holds a short bio about the user
    bio = models.TextField(blank=True, default='')
                                                                    # This field auto fills with the time of account creation
    date_joined = models.DateTimeField(default=timezone.now)
                                                                    # This field is used to determine whether the user's account is active.
    is_active = models.BooleanField(default=True)
                                                                    # This field is used to determine whether the user is a staff user
    is_staff = models.BooleanField(default=False)
                                                                    # This field is used to hold any accounts the user is followed by
    follows = models.ManyToManyField(settings.AUTH_USER_MODEL,
                                    related_name='followed_by',
                                    default='',
                                    blank=True
                                    )
                                                                    # This field is used to hold any accounts the user sfollows
    following = models.ManyToManyField(settings.AUTH_USER_MODEL,
                                    default='',
                                    blank=True
                                    )

    profile_pic = DefaultStaticImageField(blank=True)

    cover_pic = models.ImageField(blank=True, null=True)

    objects = UserManager()
                                                                    # This attribute tells Django what field to expect as the username, or
                                                                    # unique identifier for the user
    USERNAME_FIELD = 'email'
                                                                    # This attribute tells Django that the "name" field is required
    REQUIRED_FIELDS = ['name']
            </code></pre>

          <h3 id="subtitle2-1">SignUpView</h2>
          <p>The <code>SignUpView</code> class renders the <a target="_blank" href="{% url 'users:signup' %}">sign up</a> page. This handles the standard user creation process (superusers are created in the commandline), Django
          is so very kind and handles the form validation for me (this is another example of how Django handles mundane tasks for me so I can focus on the important stuff).</p>

          <pre class="line-numbers"><code class="language-python">
                                                                    # This class renders the signup template and form
class SignUpView(generic.CreateView):
                                                                    # Tell the view to use the custom form I created in forms.py
    form_class = forms.UserCreateForm
                                                                    # Redirect the user to the lgoin page once they've signed up
    success_url = reverse_lazy('login')
                                                                    # Tell the view what template to render
    template_name = 'users/signup.html'
          </code></pre>

          <p>The code below defines the form class that the signup view uses to capture the user data. The <code>UserCreateForm</code> extends Django's base <code>UserCreationForm</code>, as I have modified the base user model I must also modify the
          base user creation form.</p>
          <p>The <code>Meta</code> class has an attribute <code>fields</code>, here I specify what fields the signup form should display. The <code>model</code> attribute defines what user model we are using, in this case it is the custom user model I created.</p>

          <pre class="line-numbers"><code class="language-python">
                                                                    # This class abstracts the UserCreationForm class, this allows me to customise
                                                                    # the Django signup form
class UserCreateForm(UserCreationForm):
                                                                    # The meta class holds information...
    class Meta:
                                                                    # Define the fields that the form should hold
        fields = (
            'name',
            'email',
            'password1',
            'password2',
        )
                                                                    # This gets the user model from settings.AUTH_USER_MODEL
        model = get_user_model()
                                                                    # This method runs when the object is instantiated
    def __init__(self, *args, **kwargs):
                                                                    # Run the __init__ method on the base class we inherited from with the
                                                                    # arguments and key-word arguments supplied
        super().__init__(*args, **kwargs)
                                                                    # Set the label of the email field to a more aesthetic value
        self.fields['email'].label = 'Email Address'
          </code></pre>

          <h3 id="subtitle2-2">UpdateView</h2>
          <p>The <code>UpdateView</code> class renders the <a target="_blank" href="{% url 'users:edit' %}">profile update</a> page (must be logged in to see link). First of all the form is autofilled with the current user information so the user doesn't have to
          re-enter any information they wish to keep the same. When the user clicks the "Save changes" button the form is submitted and the subsequesnt changes to the users entry in the database is updated.</p>

          <pre class="line-numbers"><code class="language-python">
                                                                    # This class renders the page on which users can edit their profile
class UpdateProfile(LoginRequiredMixin, generic.UpdateView):
                                                                    # Set the model to the custom user model from models.py
    model = models.User
                                                                    # Set the form to the UpdateProfile form in forms.py
    form_class = forms.UpdateProfile
                                                                    # Set the redirect uel to the user's profile page
    def get_success_url(self):
        pk = self.request.user.id
        return reverse_lazy('users:profile', kwargs={'pk': pk})
                                                                    # Set the template the render
    template_name = 'users/edit_user.html'

    def get_object(self):
        return self.request.user
          </code></pre>

          <p>In an almost indenticle way to the signup view the update profile view I defined the model form. Again with the <code>Meta</code> class defining the fields to display and the model to edit.</p>

          <pre class="line-numbers"><code class="language-python">
                                                                      # This class deines the form used to update the users profile
class UpdateProfile(forms.ModelForm):
    class Meta:
        model = models.User
        fields = (
            'name',
            'email',
            'bio',
            'profile_pic',
            'cover_pic',
        )
          </code></pre>

          <h3 id="subtitle2-3">LogoutView</h2>
          <p>The <code>LogoutView</code> does not render a page or form like the views we have seen so far. It extends the <code>RedirectView</code> class, therefore when it is called it first logs the user out, kills the current user session
            and redirects the user to the homepage</p>

          <p>This is the first time we have come across the <code>reverse_lazy</code> function; this is a very useful function thay returns the URL that is related to the URL namespace.</p>

          <pre class="line-numbers"><code class="language-python">

# This class-based-view redirects the user to the home page rather than the
# default Django admin logout page
class LogoutView(generic.RedirectView):
                                                                    # Get the url linked the name "home"
    url = reverse_lazy('home')
                                                                    # This method logs the user out and runs the base LogoutView class using the
                                                                    # .super() method
    def get(self, request, *args, **kwargs):
                                                                    # This function takes the http request object and logs the user out
        logout(request)
        return super().get(request, *args, *kwargs)

          </code></pre>

          <h3 id="subtitle2-4">Profile Views</h2>
          <p>The profile views allow users to view their own profile and other users' profiles. There are two profile views: <code>profile_view_user</code> and <code>profile_view</code>. The <code>profile_view_user</code> view is rendered when a logged in
          user clicks on their own profile, it is different to the <code>profile_view</code> view as it must allow the user to edit their own prefenences and create posts. Users viewing other users' profile should not see these options as they do not
        have permission to change such settings. This is the key reason as to why I decided to go with two views.</p>

          <h4 id="subtitle2-4-1">Your Own Profile</h4>

          <p>The <code>profile_view_user</code> function-based-view renders the profile page of the current logged in user. The <code>get_profile_images</code> function is important here, it does more than just fetch
          the user's profile images from the media store. Before I introduced this function, if the user had not uploaded a profile picture it would result in a 500 response code (internal server error) as the profile picture field was blank and
          calling the <code>.url</code> method on a blank field returns an error. This functioin checks to see whether the field is blank, if so it doesn't call the <code>.url</code> method and instead outputs the path to the default profile
          picturem, thus preventing the server</p>

          <pre class="line-numbers"><code class="language-python">

# This function returns a dictionary of the urls of the user's latest profile picture and cover picture
def get_profile_images(user_id):
                                                                    # If the user has a profile picture then display the latest one
    user_profile_pic = models.User.objects.filter(id=user_id).latest('id').profile_pic
    if user_profile_pic:
        user_profile_pic = user_profile_pic.url
    else:
                                                                    # If not then display the default profile picutre
        user_profile_pic = '/media/default_profile_pic.svg'

                                                                    # If the user has a cover picture then display the latest one
    user_cover_pic = models.User.objects.filter(id=user_id).latest('id').cover_pic
    if user_cover_pic:
        user_cover_pic = user_cover_pic.url
    else:
                                                                    # If not then display the default cover picutre
        user_cover_pic = '/media/default_cover_pic.jpg'

    data = {
        'user_profile_pic': user_profile_pic,
        'user_cover_pic': user_cover_pic,
    }
    print(data)
    return data


# This function-based-view renders the user's profile page
def profile_view_user(request):
    if request.user.is_authenticated:                               # Check to see whether the user is logged in
                                                                    # Get user's information
        user = request.user

        profile_pictures = get_profile_images(user.id)              # Get the user's images

        posts = Post.objects.filter(user=user.id)                   # Get the user's posts

                                                                    # Render the template with the user object, profile pictures and post stats
                                                                    # in a context dictionary
        return render(request, 'users/profile_user.html', {
            'user': user,
            'profile_pictures': profile_pictures,
            'number_of_posts': post_stats(user.id)['number_of_posts'],
            'completed_posts': post_stats(user.id)['completed_posts'],
            'completion_percentage': post_stats(user.id)['completion_percentage'],
        })
    else:
        return HttpResponseRedirect(reverse_lazy('login'))          # If the user is not logged in then send them to the login page

          </code></pre>

          <h4 id="subtitle2-4-2">Another's Profile</h4>

          <p>The <code>profile_view</code> renders when a user clicks on a profile other than their own. It is very similar to the <code>profile_view_user</code> view with a few key differences: it has no button
          for editting prefenences and it has a follow button (the follow button was omitted from the <code>profile_view_user</code> view as a user following themselves is trivial). Also, there is no post creation
          functionality in this view as other users cannot post on profiles other than their own.</p>

          <pre class="line-numbers"><code class="language-python">

# This function-based-view renders the user's profile page
def profile_view(request, pk):
    if request.user.is_authenticated:
                                                                    # If the user tries to "view" thier own page as if they were not logged into
                                                                    # their account then run the "logged in" view
        if request.user.id == pk:
            return profile_view_user(request)

        user = get_object_or_404(models.User, id=pk)                # Get the user object

        profile_pictures = get_profile_images(user.id)              # Get the users profile images

        if request.user in user.follows.all():                      # Determine whether the user viewing the profile follows the user, this will
            following = True                                        # affect how the follow button is loaded (whether it says follow or following)
        else:
            following = False

                                                                    # Render the template with the user object and user_profile_pic url in
                                                                    # context dictionary
        return render(request, 'users/profile.html', {
            'user': user,
            'user_viewing': request.user.id,
            'following': following,
            'profile_pictures': profile_pictures,
            'number_of_posts': post_stats(user.id)['number_of_posts'],
            'completed_posts': post_stats(user.id)['completed_posts'],
            'completion_percentage': post_stats(user.id)['completion_percentage'],
        })
    else:
        return HttpResponseRedirect(reverse_lazy('login'))

          </code></pre>


          <h3 id="subtitle3">Templates</h3>
          <p>So far nothing very special has happened, I have mainly been laying down the base functionality. So far Peerspace does not take into account the user and their prefenences, so this is where the user preference tag system comes in. When a
          user signs up there are no preference tags associated with their account so the feed algorithm is nothing more than a randomiser (much more on the feed algorithm in the <a href="#title2">Post App</a> section). The user preference tags let
          Peerspace determine what posts the user is most likely to engage with (this is important as Peerspace aims to encourage collaboration, if users aren't interested in what they see, naturally they won't collaborate).</p>

          <h3 id="subtitle3-1">What Are Templates?</h3>

          <p>Templates are the HTML files that Django's views render. For example the <code>layout.html</code> template is the base layout structure of Peerspace:</p>

            <pre class="line-numbers"><code class="language-python">

              {&#37; load static &#37;}

              &lt;!doctype html&gt;
              &lt;html lang=&quot;en&quot;&gt;
                &lt;head&gt;
                  &lt;title&gt;{% block title_tag %}Peerspace{% endblock %}&lt;/title&gt;
                  &lt;link rel=&quot;shortcut icon&quot; href=&quot;{% static 'img/favicon.ico' %}&quot;&gt;
                  &lt;!-- Required meta tags --&gt;
                  &lt;meta charset=&quot;utf-8&quot;&gt;
                  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;
                  &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'css/layout.css' %}&quot;&gt;
                  &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'dist/toolkit.css' %}&quot;&gt;
                  &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static 'dist/toolkit.css.map' %}&quot;&gt;
                  &lt;!-- Bootstrap CSS --&gt;
                  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css&quot; integrity=&quot;sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb&quot; crossorigin=&quot;anonymous&quot;&gt;
                &lt;/head&gt;
                &lt;body&gt;
                  &lt;nav class=&quot;navbar fixed-top navbar-expand-lg navbar-dark bg-dark&quot;&gt;
                    &lt;div class=&quot;container&quot;&gt;
                      &lt;!-- &lt;div class=&quot;navbar-container&quot;&gt; --&gt;
                      &lt;a class=&quot;navbar-brand&quot; href=&quot;{% url 'feed' %}&quot;&gt;
                          &lt;img src=&quot;{% static 'img/logo.png' %}&quot; width=&quot;30&quot; height=&quot;30&quot; class=&quot;d-inline-block align-top&quot; alt=&quot;Go to feed&quot;&gt;
                          Peerspace
                        &lt;/a&gt;
                        &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt;
                          &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt;
                          &lt;ul class=&quot;navbar-nav mr-auto&quot;&gt;
                            &lt;li class=&quot;nav-item&quot;&gt;
                              &lt;a class=&quot;nav-link&quot; href=&quot;{% url 'users:profile_user' %}&quot;&gt;Profile&lt;/a&gt;
                            &lt;/li&gt;
                            &lt;li class=&quot;nav-item&quot;&gt;
                              &lt;a class=&quot;nav-link&quot; href=&quot;{% url 'feed' %}&quot;&gt;Feed&lt;/a&gt;
                            &lt;/li&gt;
                            &lt;li class=&quot;nav-item&quot;&gt;
                              &lt;a class=&quot;nav-link&quot; href=&quot;{% url 'users:logout' %}&quot;&gt;Logout&lt;/a&gt;
                            &lt;/li&gt;
                          &lt;/ul&gt;
                          &lt;form class=&quot;form-inline my-2 my-lg-0&quot;&gt;
                            &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;search&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot;&gt;
                            &lt;button class=&quot;btn btn-outline-light mr-0  my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;&lt;span class=&quot;icon icon-plus&quot;&gt;&lt;/span&gt;&lt;/button&gt;
                          &lt;/form&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                  &lt;/nav&gt;
              &lt;/div&gt;
                  {&#37; block body_content &#37;}
                  {&#37; endblock body_content &#37;}
                  &lt;!-- Optional JavaScript --&gt;
                  &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt;
                  &lt;!-- &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; --&gt;
                  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js&quot; integrity=&quot;sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
                  &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js&quot; integrity=&quot;sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
                  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js&quot;&gt;&lt;/script&gt;
                &lt;/body&gt;
              &lt;/html&gt;


            </code></pre>


            <p>The <code>layout.html</code> page has markup and style that form the navigation bar at the top of the page, other templates then "extend" this layout template. This means I don't need to include the navigation markup and styles in every single template. You can
              read more about <a target="_blank" href="https://docs.djangoproject.com/en/2.0/topics/templates/">Django templates</a> in the Django docs.</p>

            <p>The users app has five templates:</p>
            <ul>
              <li><p><code>profile.html</code> allows users to view their own profiles.</p></li>
              <li><p><code>profile_user.html</code> allows users to view other users' profiles.</p></li>
              <li><p><code>signup.html</code> displays the form allowing new users to create an account.</p></li>
              <li><p><code>edit_user.html</code> displays the form allowing users to edit their accounts.</p></li>
              <li><p><code>edit_tags</code> displays the form allowing users to edit their preference tags.</p></li>
            </ul>

            <p>Each of these templates is rendered by a particular view, see the Django docs for how views render templates: <a target="_blank" href="https://docs.djangoproject.com/en/2.0/topics/http/views/">Django's Views.</a></p>

        </section>

        <section>
          <h2 id="title2">Posts App</h2>
          <p>The post app handles everything todo with post creation, storage and retrieval. It is fundemental to Peerspace as the site relies on the user's ability to take their commitments public and thereby "post" to other users information about any such commitments.</p>
          <p>As well as providing posting functionality the post app also allows users to comment on their own and other users' posts, this is important as it allows open communication between users and this is essential to encouraging collaboration.</p>

          <h3 id="subtitle4">Post Model</h3>
          <p>The post model defines the table that holds all of the data relevant to each post. </p>

          <pre class="line-numbers"><code class="language-python">

# This class defines the Post model
class Post(models.Model):
                                                                    # The exact time at which the post was created
    created_at = models.DateTimeField(default=timezone.now, blank=True)
                                                                    # The title of the posts
    title = models.CharField(max_length=255)
                                                                    # The description of the post (max_length is 140 to allow for easy
                                                                    # integration with Twitter)
    description = models.TextField()
                                                                    # Whether or not the post has been completed
    completed = models.BooleanField(default=False)
                                                                    # The User is the foreign key (one post can belong to one user,
                                                                    # one user can have many posts)
    user = models.ForeignKey(settings.AUTH_USER_MODEL,
                                unique=False,
                                null=True,
                                on_delete=None,
                                related_name='posts'
                            )
    likes = models.ManyToManyField(settings.AUTH_USER_MODEL, blank=True, related_name='likes')

    tags = models.TextField(null=True, blank=True)

    # deadline = models.DateField(blank=True, default=None)

    proof_description = models.TextField(blank=True, null=True, default=None)

    proof_pic = models.ImageField(blank=True, null=True, default=None)

    verifications = models.ManyToManyField(settings.AUTH_USER_MODEL, blank=True, related_name='verfs')

    days_taken = models.IntegerField(blank=True, default=None, null=True)

    comments = models.ManyToManyField(Comment, blank=True, related_name='comments')

                                                                    # This will overide the __str__ method so when it is referred to it is
                                                                    # in a readable form
    def __str__(self):
        return '{} by: {}'.format(self.title, self.user)

    def get_user(self):
        return user.name
                                                                    # This will return the number of days since the post was created
    @property
    def time_since_creation(self):
        return (timezone.now() - self.created_at).days
                                                                    # This will return the absolute url of the post
    def get_absolute_url(self):
        return reverse_lazy('posts:post_detail', kwargs={'pk':self.id})
                                                                    # This will determine whether enough users have verified the post
    def is_verified(self):
        if self.verifications >= 5:
            return True
        return False
          </code></pre>

          <p>There is nothing special about the post model, the data structure is fairly basic. It has a few interesting methods that make life easier throughout the site. The <code>time_since_creation</code> property allows me to
            return how many days (as an integer) it has been since the post was created, doing this here in the model conforms with Django's DRY (don't repeat yourself) policy as anywhere I need to get the number of days since the post
            was created I can just call the <code>.time_since_creation</code> method easily.</p>

            <h3 id="subtitle4-1">Post List View</h3>
            <p>The post list view renders the layout page for the post feed, it doesn't actually render or display any posts (this is done by the <a href="title3">API</a>), it simply renders the page into which the posts are loaded by the API.</p>

            <pre class="line-numbers"><code class="language-python">
def post_list(request):
    if request.user.is_authenticated:                             # Check whether the user is logged in
        user = request.user                                       # Get the user instance from the request
        profile_pictures = get_profile_images(user.id)            # Get the users profile images
        number_of_posts = models.Post.objects.filter(user=user.id).count()
        return render(request, 'posts/post_list.html',            # Render the template with a context dictionary containing relevant information
                        {
                            'user': user,
                            'profile_pictures': profile_pictures,
                            'number_of_posts': number_of_posts,
                        }
                    )
    else:
        return HttpResponseRedirect(reverse_lazy('login'))        # If the user is not logged in then redirect them to the login page
            </code></pre>

            <p>There is nothing special going on with this view, the context dictionary is the data that is accessible by the template when it is rendered.</p>

            <h3 id="subtitle4-2">Post Edit View</h3>
            <p>The post list view renders the layout page for the post feed, it doesn't actually render or display any posts (this is done by the <a href="title3">API</a>), it simply renders the page into which the posts are loaded by the API.</p>

            <pre class="line-numbers"><code class="language-python">
# The view gets the primary key of the post from the &lt;int:pk&gt; keyword argument (kwarg or kwargs) from the url.
def post_edit(request, pk=None):
                                                                  # Get all the users posts
    user_posts = models.Post.objects.filter(user=request.user.id)
                                                                  # Get the post that the user is trying to edit
    instance = get_object_or_404(models.Post, pk=pk)
                                                                  # Check to see whether the user actaully owns the post they are trying to edit
    if instance in user_posts:
                                                                  # Get the user's input from the form
        form = forms.UpdatePost(request.POST or None, request.FILES or None, instance=instance)
                                                                  # Validate the form
        if form.is_valid():
            instance = form.save(commit=False)
            instance.save()
                                                                  # Once complete redirect the user to the post they just edited
            return HttpResponseRedirect(instance.get_absolute_url())
        context = {
            'pk': pk,
            'title': instance.title,
            'description': instance.description,
            'tags': instance.tags,
            'form': form,
        }
                                                                  # Render the page with the form
        return render(request, 'posts/edit_post.html', context)
    else:
                                                                  # If the user is not the owner of the post then redirect them to the post (this stops them from editing other people's posts).
        return HttpResponseRedirect(instance.get_absolute_url())
            </code></pre>

            <p>The <code>context</code> dictionary will autofill the form with the current post data, without this the user would have to re-enter data that they didn't want to change.</p>


            <h3 id="subtitle4-3">Post Edit View</h3>
            <p>The post list view renders the layout page for the post feed, it doesn't actually render or display any posts (this is done by the <a href="title3">API</a>), it simply renders the page into which the posts are loaded by the API.</p>

            <pre class="line-numbers"><code class="language-python">
def prove_post(request, pk=None):
                                                                  # Check to see if the user is logged in
    if request.user.is_authenticated:
                                                                  # Get all of the users posts
        user_posts = models.Post.objects.filter(user=request.user.id)
                                                                  # Get the post being proved
        post = get_object_or_404(models.Post, pk=pk)
                                                                  # The user is the owner of the post then go ahead and load the form
        if post in user_posts:
            form = forms.ProvePost(request.POST or None, request.FILES or None, instance=post)
                                                                  # Validate the form
            if form.is_valid():
                post = form.save(commit=False)
                                                                  # If the user has correctly proved the post then set the "days_taken" attribute to the number of days between
                                                                  # the post creation and post completion
                if post.proof_description and post.proof_pic:
                    post.days_taken = (timezone.now() - post.created_at).days
                post.save()
                return HttpResponseRedirect(post.get_absolute_url())
            context = {
                'pk': pk,
                'form': form,
            }
            return render(request, 'posts/prove_post.html', context)
        else:
                                                                  # If the user doesn't own the post then don't let them edit it and redirect them
            return HttpResponseRedirect(instance.get_absolute_url())
    else:
                                                                  # If they are not logged in redirect them to the login page
        return HttpResponseRedirect(reverse_lazy('login'))
            </code></pre>

            <p>The <code>context</code> dictionary gives the template the needed data to autofill the form with the current post data, without this the user would have to re-enter data that they didn't want to change.</p>

            <h3 id="subtitle4-4">Post View</h3>

            <p>In contrast to the profile views there is only one post view, it renders one of two templates: one for users to view their own posts and one for users to view other users' posts. The reason for having two post detail templates is also very similar to the reason for
              having two profile view templates; there are different controls depending on whether the user owns the post or not. If they view a post that they own then they will see the standard like, comment and verify (if proof has been submitted) buttons, whereas
              if the user views a post they own then they will see the submit proof, edit post and delete post buttons.</p>

            <h4 id="subtitle4-4-1">Your Post</h4>

            <p>The <code>post_view</code> view renders the <code>post_detail_user</code> template containing a post, this post is owned by the viewing user therefore they see the submit proof, edit post and delete post buttons.</p>

            <pre class="line-numbers"><code class="language-python">

def post_view(request, pk):
                                                                  # Check to see if the user is logged in
    if request.user.is_authenticated:
                                                                  # Get the post object for the post being viewed
        post = get_object_or_404(models.Post, pk=pk)
                                                                  # Check to see if the user owns the post
        if request.user.id == post.user_id:
                                                                  # Get the user's profile picture's url
            user_profile_pic = User.objects.filter(id=request.user.id).latest('id').profile_pic.url
                                                                  # Render the post_detail_user template
            return render(request, 'posts/post_detail_user.html',
                            {
                                'post': post,
                                'user_profile_pic': user_profile_pic,
                                'root_url': root_url,
                            }
                         )
        else:
                                                                  # If the user doesn't own the post then render the post_detail page
            return render(request, 'posts/post_detail.html',
                            {
                                'post': post,
                                'root_url': root_url,
                            }
                         )
    else:
                                                                  # If the user is not logged in then redirect them to the login page
        return HttpResponseRedirect(reverse_lazy('login'))

            </code></pre>

            <p>With many of the views I have shown so far there is process of user authenticaiton, I feel I need to address this a little more. The <code>request.user.is_authenticated</code> method will return a boolean value that
            indicated whether the user is logged into Peerspace. This check alone is not enough to prevent users from editing other user's posts as it only checks to see if the user is logged in, therefore as long as a user if logged in
          they could run rampent changing everyone's posts. This is why in many view I make sure to check the user owns the post before allow them to make changes. In this view I check to see whether the user making the request matches
        the id of the user who owns the post, if so then let them edit it and if not so I redirect them to the <code>post_detail</code> view that does not have the submit proof, edit and delete buttons.</p>

        <h4 id=subtitle4-4-2>Another's Post</h4>

        <p>When a user views a post that is not their own the aforementioned <code>post_view</code> view renders the <code>post_detail</code> template. Unlike the <code>post_detail_user</code> template the <code>post_detail</code> template does not
        render the post, the post information is provided by the <a href="#title3">API</a> (more on the reason for this in a later section).</p>

        <h3 id="subtitle5">Post Feed</h3>

        <p>The post feed is the first screen a user is redirected to after they login or signup, it is the "homepage" of the application so to speak. The post feed contains what Peerspace believes to be the 20 most relevant posts according to each user's
        preferences, user's they follow and general activity on the site.</p>

        <p>There are three key metrics the feed algorithm uses to determine a relevance score for each post:</p>

        <ul>
          <li><strong>Preference tags</strong>: the more tags the post has that match the user's preference tags the higher the relevance score.</li>
          <li><strong>Post creation date</strong>: the sooner the post creation date the higher the relevance score.</li>
          <li><strong>The post owner</strong>: any posts owned by users that the user follows will have a higher relevance score.</li>
        </ul>

        <p>Building the post feed system has really opened my eyes to how powerful Django can be. The <code>feed.py</code> has nothing to do with Django, it is just a file containing a function and with Django I can use this function with ease to affect
          how things are displayed on the web. This may be an obvious feature, but I really like how easy Django makes it to build web applications.</p>

        <h3 id="subtitle5-1">Preference Tags</h3>

        <p>Preference tags are one of the three key metrics the feed algorithm uses to determine the most relevant posts. The function of the preference tags is to create a link between a user and posts that user may engage with (this is important as Peerspace aims to encourage collaboration, if users aren't interested in what they see, naturally they won't collaborate).
          There are two places where tags are stored: each user has a list of tags each with a weight (more on this later) and each post also has a list of tags (with no weight).</p>

        <h4 id="subtitle5-1-1">User Tag Model</h4>

        <p>The user tag model holds two important pieces of date for each tag: the tag itself and the weight of the tag. There is a <code>ManyToOne</code> relation between the tag model and the user model; each user can have many tags yet a tag can only belong to one
          user, this is because the weight of the tag is specific to the user.</p>

        <pre class="line-numbers"><code class="language-python">
# This class holds the user's preferences
class UserPreferenceTag(models.Model):
                                                          # The name of the tag. There can be more than one tag with the same name
    tag = models.CharField(max_length=100, unique=False)
                                                              # This field is better described in the section containing the relation
                                                              # algorithm. It holes the weight of the tag as a float
    weight = models.DecimalField(max_digits=10, decimal_places=5, default=0.5)
                                                              # This is the foreign key that relates the user to the tag
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=None)

                                                              # This method reterns the tag name and weight when it is referenced
    def __str__(self):
    return "{}: {}".format(self.tag, self.weight)
        </code></pre>

        <p>The <code>user</code> field is the relation between a tag and a user. There may be 400 tags with the <code>tag</code> "cricket" yet they would all be unique in the fact they relate to different users (I am being a bit ambitious saying there are 400 Peerspace users...). I go more in-depth in the
        reason for this in the <a href="#subtitle6">relevance algorithm</a> section.</p>

        <h4 id="subtitle5-1-2">Post Tags</h4>

        <p>The post tag system is much more simple than the user tag system, this is because each post's tags are stored as a comma-seperated list rather then a whole seperate model. The reason there is no model for the post tags is because the weight of the tag for each post is not important (the weight of the uset tag
          is important as it affects how the <a href="#subtitle6">relevance algorithm</a> works).</p>

        <pre  class="line-by-line"><code class="language-python">
# This is the field in the post model that stores the post's tags
tags = models.TextField(null=True, blank=True)
        </code></pre>

        <h3 id="subtitle6">Relevance Algorithm</h3>

        <p>The relevance algorithm is the brain of Peerspace, currently it is very young and dumb; as Peerspace grows I plan to integrate machine learning techniques (once I learn more about data science) into the algorithm to improve its operation.</p>

        <p>If a user's feed is populated with posts that they don't engage with they will lose interest, not collaborate and ultimately stop using Peerspace. The relevance algorithm is at the core of Peerspace, it works to populate the each user's feed
          with the most relevant, up-to-date and engaging content. The more posts the user engages with the more likley they are to collaborate with others, this is imperative as the vision of Peerspace is to promote collaboration.</p>

          <pre class="line-numbers"><code class="language-python">
            # Input: a user
            # Output: a prediction of the most relevent posts

            # Get the user's tags
            # Get the post's tags
            # Compare tags
            # If tags match multiply score by tag's weight
            # Multiply score by output of the date relevance function

            from users.models import UserPreferenceTag
            from users.models import User
            from posts.models import Post

            from django.shortcuts import get_object_or_404

            import math
            import random
            import decimal

            def get_most_relevent(user_pk, page_number, page_size):

                                                                                # Get user's information
                user = get_object_or_404(User, pk=user_pk)
                                                                                # Get all user's tags
                user_tags = UserPreferenceTag.objects.filter(user=user_pk)
                                                                                # Get all posts (in last x amount of time)
                post_slice1 = (page_number * page_size)
                post_slice2 = (page_number * page_size) + 10
                posts = Post.objects.order_by('-created_at')[post_slice1:post_slice2]

                                                                                # The slicing prevents the algorithm from re-running on the same posts twice

                                                                                # E.g.

                                                                                # No slicing
                                                                                # post_ids:  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18...]
                                                                                # first run:  ^ ^ ^ ^ ^ ^ ^ ^ ^ ^  ^  ^  ^  ^  ^  ^  ^  ^

                                                                                # With slicing
                                                                                # post_ids:  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18...]
                                                                                # first run:  ^ ^ ^ ^ ^ ^ ^ ^ ^

                                                                                # post_ids:  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18...]
                                                                                # second run:                   ^  ^  ^  ^  ^  ^  ^  ^  ^

                                                                                # Gives a list of all the user's tags
                user_tag_list = [tag.tag.lower() for tag in user_tags]

                                                                                # Initialise the results dictionary
                score_dict = {}
                runtimes = 0
                for post in posts:
                    runtimes += 1
                                                                                # Initialise some varibles
                    total_score = 0
                    tag_score = 0
                    num_tags_match = 0
                    count = 0
                    follower_tag_count = 0
                    num_days = post.time_since_creation
                    does_follow = False

                                                                                # Get the user object of the owner of the post
                    post_owner = get_object_or_404(User, pk=post.user.id)

                                                                                # If the user follows the post owner then increase the relevance with each
                                                                                # preference tag that matches
                    if post_owner in user.following.all():
                                                                                # Even if no preference tags match, increase base relevance
                        tag_score = 0.15

                        does_follow = True

                                                                                # Get post_owner's tags
                        post_owner_tags = [tag.tag.lower() for tag in UserPreferenceTag.objects.filter(user=post_owner)]

                                                                                # Add to the tag_score if any posts match
                        for tag in post_owner_tags:
                            if tag in user_tag_list:
                                tag_score += (1 / (1 + math.exp(-user_tags[count].weight)))
                            follower_tag_count += 1

                                                                                # Get all of the current post's tags
                    post_tag_list = post.tags.split(", ")
                                                                                # Lower case all tags with a list comprehension
                    post_tag_list = [tag.lower() for tag in post_tag_list]
                    for user_tag in user_tag_list:
                        if user_tag in post_tag_list:
                                                                                # Normalise the weight (make sure it is in range 0 to 1) by using
                                                                                # the logistic sigmoid
                            tag_score += (1 / (1 + math.exp(-user_tags[count].weight)))
                            num_tags_match += 1
                        count += 1

                    if num_tags_match == 0:
                                                                                # If no tags match then give the post a random score. This may
                                                                                # introduce the user to a new area of interest
                        wildcard_score = random.random() * 0.5
                                                                                # This is the same date relevance and normalisation process as seen
                                                                                # below
                        wildcard_score *= math.exp((-1/4) * num_days)
                        total_relevance = 1 / (1 + math.exp(-wildcard_score))
                        score_dict.update({post.id: total_relevance})
                    else:
                        total_relevance = decimal.Decimal(tag_score)
                                                                                # Multiply the total relevance by a funtion that is large for a
                                                                                # small number of days and small for a large number of days
                        total_relevance *= decimal.Decimal(math.exp((-1/4) * num_days))
                                                                                # Output scores to a dictionary
                        score_dict.update({post.id: total_relevance})
                                                                                # This line is extremely useful for development purposes.

                        print(('Id: {}, title: {} and score: {}. {} tags matched. User follows: {} {} follower tags matched.').format(
                                                                                                                                   post.id,
                                                                                                                                   post.title,
                                                                                                                                   total_relevance,
                                                                                                                                   num_tags_match,
                                                                                                                                   does_follow,
                                                                                                                                   follower_tag_count
                                                                                                                               )

                              )
                                                                                # Order score_dict by value and give an ordered list of post ids
                output = {}
                sorted_score_dict = sorted(score_dict, key=score_dict.__getitem__)
                for k in sorted_score_dict:
                    output.update({k: score_dict})
                post_ids = list(output.keys())
                post_ids = post_ids[::-1]
                print(post_ids, runtimes)

                # When considering efficieny this function queries the database 2 + n times
                # where n is the number of posts in the last 10 days

                return post_ids

          </code></pre>

          <p>There are two mathematical functions that the algorithm uses:</p>

          <ul class="pb-3">
            <li><strong>Logistic Sigmoid</strong>: this function is used to normalise the results (it will reduce the range of the output be between 0 and 1).</li>
            <li><strong>Exponentional</strong>: this function takes the number of days since the post was created and outputs a number between 0 and 1. A post's relevance will decrease exponentionally with number of days since its creation.</li>
          </ul>

          <div class="col-lg-6">
            <h4>Logistic Sigmoid</h4>
            <p>With large x this function will tend towards one and with small x it will ten towards 0. This function plays a vital role in the relevance algorithm; if I didn't use this function and a post matched a user tag
               with a very large weight then this post would have a much higher relevance than others yet only one tag has been matched. By using this function I can restrict a single
               tag's affect on the outcome to a range of 0 to 1, this means that the relevance score is affected by <strong>how many tags match</strong> and not only whether one tag has a very high (or very low weight).</p>
            <div class="sigmoid">
              <iframe src="https://www.desmos.com/calculator/4sdo9rbhdg?embed" class="graph" width="500px" height="500px" style="border: 1px solid #ccc" frameborder=0></iframe>
              <img src="{% static 'img/Sigmoid.png' %}">
            </div>
          </div>

          <!-- <div class="spacer col-lg-1"></div> -->

          <div class="col-lg-6">
            <h4>Negative Exponentional</h4>
            <p>This is a function in time for the "time relevance coefficient" (I completely made that up), it takes the number of days since the post was created and spits out a number
               between 1 and 0. If the post was created today it returns 1 and as the number of days increase the time relevance coefficient (I need to think of a better term) decreases exponentionally. It is an
               assumption on my part that the relevance of a post should decrease as time goes on, it would make sense that people would want to see fresh new posts rather than old ones.</p>
            <div class="expon">
              <iframe src="https://www.desmos.com/calculator/a6zkdittrx?embed" class="graph" width="500px" height="500px" style="border: 1px solid #ccc" frameborder=0></iframe>
              <img src="{% static 'img/expon.png' %}">
            </div>
          </div>


          <h5 class="mt-5">Testing the algorithm</h5>
          <p>The console log shows how the algorithm analyses each post.</p>

          <img src="{% static 'img/console_log.png' %}">

          <p>The information printed to the console shows the metrics used to determine the relevance score. We can see that the posts with the highest number of post tag matches, most number of follower tag matches and are the most recent have the highest score, perfect.</p>
          <p>Posts that match no preference tags are not discarded though, I have introduced a "wildcard score". The <code>wildcard_score</code> is a psuedo random number that is given in place of the <code>tag_score</code> metric, it means that if a post doesn't match any tags
            it still has a chance of placing highly in the feed. My reason for doing this is to allow the feed to present potential new interesets to the users. If they only ever saw things that they were familiar with they may get bored and not engage with the content, but this is
            where the wildcard score system comes into place. Also a post with no matching tags but matching follower tags will still be randomised yet the overall relevance score will be higher

        </section>

        <section>
          <h2 id="title3">API</h2>
          <p>Peerspace's API (application program interface) is the medium through which the frontend (client-side) communicates with the backend (server-side). It is the spinal cord of Peerspace and is absolutly essential to its operation. The
          API is built using the <a href="http://www.django-rest-framework.org/" target="_blank">Django REST (Representational State Transfer) framework</a>. From a high-level perspective the API works to give the frontend what it asks for (the browser is very needy). A series
          of GET, POST, PUT and DELETE requests form the commmunication layer. The frontend uses AJAX (asynchronous JavaScript and XML) to make such requests, this allows the DOM (document object model) to be updated without the need for a page refresh, this gives life to a dynamic user interface.</p>

          <h3 id="subtite7">Serializers</h3>

          <p>Although spelt incorrectly, Django REST framework's serializers are incredably useful. They take a model instance and convert the data into a format called JSON (JavaScript Object Notation), this data format is used widely across the web and is the standard data transfer medium. It is lightweight and
            is very readable by both humans and computers.</p>

          <p>The code below is the <code>UserSerializer</code> class that tells Django REST framework what pieces of data should be included in the response:

          <pre class="line-numbers"><code class="language-python">
# This class takes the data from the User model and serializes it into JSON
# (JavaScript Object Notation) ready for use in the API
class UserSerializer(serializers.ModelSerializer):

    class Meta:
                                                                    # Define the model to use
        model = models.User
                                                                    # Define which fields to output
        fields = (
                                                                    # The id field does not appear in the User model as it is an auto
                                                                    # incramenting value that the database handles for us
            'id',
            'email',
            'name',
            'bio',
            'education',
            'work',
            'location',
            'date_joined',
            'is_active',
            'is_staff',
            'posts',
            'profile_pic',
        )
          </code></pre>

          <p>This is very similar to the <code>ModelForm</code> classes we came across earlier. The <code>Meta</code> class has two key attributes: <code>model</code> and <code>fields</code>. The <code>model</code> attribute tells the serializer what model to interact with and
            the <code>fields</code> atrribute tells the serializer what fields should be included. All of the serializers look very similar, thus this will be the only one we shall talk about here.</p>

          <h3 id="subtite8">API Views</h3>

          <p>I can extend Django REST framework's <code>APIView</code> class to create my own API views. Each <code>APIView</code> class has two key attributes: <code>authenticaiton_classes</code> and <code>permission_classes</code>, these attributes are tuples that define how
          the view handles authenticaiton and permissions. The methods of the class define what the view is to do with each type of CRUD (create, update, delete and destroy) operation. For example the code in the <code>get</code> method will run when a GET request is send to
        server will the url linked to the view. I can pass it arguments taken from the url, in the example below a url ending with "/25/10/" would give the <code>get</code> method a <code>pk</code> of 25 and a <code>page_size</code> of 10.
         It will then return serialised data in the body of the response form of JSON.</p>

        <pre class="line-by-line"><code class="language-python">
class SuggestedUsers(APIView):
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticated,)

    def get(self, request, format=None, pk=None, page_size=None):
                                                                      # Get the logged in user
        main_user = get_object_or_404(models.User, pk=pk)
                                                                      # Get the users the logged in user follows
        following = main_user.following.all()
                                                                      # Get tags of the logged in user
        main_user_tags = models.UserPreferenceTag.objects.filter(user=main_user)
                                                                      # Put the tags into a list (rather than a querysey)
        main_user_tags_list = [tag.tag.lower() for tag in main_user_tags]

        score_dict = {}

        suggested_users = 0

        for user in following:
                                                                      # Get the users they follow
            user_following = user.following.all()
                                                                      # Loop through each user
            for user in user_following:

                if not user in main_user.following.all():
                                                                      # Get the user's tags
                    tags = models.UserPreferenceTag.objects.filter(user=user)
                    tags = [tag.tag.lower() for tag in tags]
                    count = 0
                    score = 0
                    for tag in tags:
                        if tag in main_user_tags_list:
                            score += (1 / (1 + math.exp(-main_user_tags[count].weight)))
                        count += 1
                    score_dict.update({user.id: score})
                    # print('Id: {} and score: {}'.format(user.id, score))

        sorted_score_dict = sorted(score_dict, key=score_dict.__getitem__)
        output = {}
        for k in sorted_score_dict:
            output.update({k: score_dict})
        user_ids = list(output.keys())[::-1][:page_size]

        data = []
        for id_ in user_ids:
            user = get_object_or_404(models.User, pk=id_)
            if not user == main_user:
                data.append(
                    {
                        'id': user.id,
                        'name': user.name,
                        'profile_pic': get_profile_images(user.id)['user_profile_pic'],
                    }
                )

        return Response(data)
        </code></pre>

          <h4 id="subtitle8-1">URLs</h4>
          <p>I have mentioned urls (universal resource locators) on several occasions, I feel it necessary to address them in greater depth. Each app has and the project root itself has a <code>urls.py</code> file.
          In the <code>urls.py</code> file I can define paths using Django's <code>path()</code> function (this is new in Django 2.0, previous versions used a function called <code>url()</code>), below is an example from Peerspace's posts app:</p>

          <pre class="line-by-line"><code class="language-python">
# Standard imports
from django.urls import path

# Import any viewsW
from . import views

# Define the namespace
app_name = 'posts'

# Define the url patterns to look for
urlpatterns = [
    # View urls
    path(
        '',
        views.post_list,
        name='post_list'
    ),
    path(
        '&lt;int:pk&gt;/',
        views.post_view,
        name='post_detail'
    ),
    path(
        '&lt;int:pk&gt;/edit/',
        views.post_edit,
        name='edit'
    ),
    path(
        '&lt;int:pk&gt;/delete/',
        views.DeletePost.as_view(),
        name='delete'
    ),
    path(
        '&lt;int:pk&gt;/prove/',
        views.prove_post,
        name='prove'
    ),
    path(
        '&lt;int:pk&gt;/prove/delete_confirm/',
        views.prove_post_delete_confirm,
        name='prove_delete_confirm'
    ),
    path(
        '&lt;int:pk&gt;/prove/delete/',
        views.prove_post_delete,
        name='prove_delete'
    ),
    # API urls
    path(
        'api/v1/',
        views.ListCreatePost.as_view(),
        name='API_post_list'
    ),
    path(
        'api/v1/profile/&lt;int:user_id&gt;/',
        views.ProfilePostList.as_view(),
        name='API_profile_posts'
    ),
    path(
        'api/v1/&lt;pk&gt;/',
        views.RetrieveUpdateDestroyPost.as_view(),
        name='API_post_detail'
    ),
    path(
        'api/v1/&lt;int:pk&gt;/like',
        views.PostLikeAPI.as_view(),
        name='API_post_like'
    ),
    path(
        'api/v1/&lt;int:pk&gt;/verify',
        views.PostVerficationAPI.as_view(),
        name='API_post_verifys'
    ),
    path(
        'api/v1/&lt;int:pk&gt;/comment',
        views.ListCreateComment.as_view(),
        name='API_post_comment'
    ),
    path(
        'api/v1/comments/&lt;int:pk&gt;/',
        views.DestroyViewComment.as_view(),
        name='API_post_comment_delete'
    ),
    path(
        'api/v1/feed/&lt;int:user_id&gt;/&lt;int:page_number&gt;/',
        views.FeedPostList.as_view(),
        name='feed'
        ]
    ),
          </code></pre>

          <p>If a request is made to a url that matches one of the urls defined then Django will run the view that is defined in the <code>path()</code> function. The first argument defines the url, the second argument
            defines the view to run and the third argument defines its name (therefore to use the function: <code>path(url, view, name)</code>).

            <section>

              <h2 id="title5">Conclusion</h2>

              <p>Building Peerspace has been an intresting journey, I am proud of my creation but I am aware there is much more work to be done, many elements of Peerspace (as they are now) simply wouldn't scale, thus limiting the
                potential of the site from the get go. In completing (or abandoning as I would never say a project is ever complete) Peerspace I have learning a vast amount about the web, Python and Django. These tools will certainly come in
                extremely useful when working on future projects. I hope you have as much fun on Peerspace as I had making it. Cheers.</p>

            </section>

      </article>
      <!-- END Main content -->
    </main>


    <!-- Footer -->
    <footer class="site-footer">
      <div class="container-fluid">
        <a id="scroll-up" href="#"><i class="fa fa-angle-up"></i></a>

        <div class="row">
          <div class="col-md-6 col-sm-6">
            <p>Copyright &copy; 2017. All right reserved</p>
          </div>
          <div class="col-md-6 col-sm-6">
            <ul class="footer-menu">
              <li><a href="page_changelog.html">Changelog</a></li>
              <li><a href="page_credits.html">Credits</a></li>
              <li><a href="mailto:support@thetheme.io">Contact us</a></li>
            </ul>
          </div>
        </div>
      </div>
    </footer>
    <!-- END Footer -->

    <!-- Scripts -->
    <script src="{% static 'assets/js/theDocs.all.min.js' %}"></script>
    <script src="{% static 'assets/js/custom.js' %}"></script>

  </body>
</html>
